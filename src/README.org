* Lintcode 解题思路记录
** Convert Sorted List to Binary Search Tree[Medium]
Given a singly linked list where elements are sorted in ascending order, 
convert it to a height balanced BST.

#+BEGIN_SRC Java
public static TreeNode sortedListToBST(ListNode head)
#+END_SRC

*思路* ：递归实现：
 
base case: List为空时，返回 =null= ，List仅有一个元素时，返回一个仅含该元
素的叶子节点；

recursion: 找到中间的Node，将其val作为BST根节点的val，将其左子树设置为在
其左子链表上递归调用此函数的结果，右子树设置为在其右子链表上递归调用此函数
的结果。最后返回这个根节点的引用。

*实现细节*

中间的Node指的是链表的第 =N/2 + 1= 个Node，即若有3个Node，指的是第二个，若
有4个Node，指的是第三个；

为将原链表从中间分为左右两部分，右部分即为中间Node的next指向的链表，而对
左部分，需要将中间Node的前一Node的next设置为null，以从中间断开，因此程序中
真正需要获取的是中间前一Node的reference，所以程序中以及下图中的middle也许
叫middlePre更合适。

#+CAPTION: middle的指向
#+NAME:   fig:FindMiddle
[[../image/SortedListToBST.png]]

很多链表题目的中间过程需要定位到链表的中间节点，注意不同题目具体的需求不同，
可能需要定位到中间的元素，也可能需要定位到中间元素的前一元素，而且对于中间
元素在奇偶长度下的定义也可能不同（尤其是偶数时），所以很多solution中虽都有
findMiddle这一helper function，但是具体细节可能有差异。

findMiddle这个函数的实现一般是通过fast和slow指针完成的，但是也可先统计一遍
链表的长度，再定位到长度的一半，两者的时间复杂度是相同的。

*参考解法*
上面的解法时间复杂度为 =O(nlgn)= ，参考答案给出了一种复杂度为 =O(n)= 的解法：
#+BEGIN_SRC Java
// method 2 O(n)
private static ListNode current;

private static int lengthOfList(ListNode head) {
    int cnt = 0;
    for (; head != null; head = head.next, cnt++) ;
    return cnt;
}

public static TreeNode sortedListToBST(ListNode head) {
    current = head;
    int length = lengthOfList(head);
    return sortedListToBSTHelper(length);
}

private static TreeNode sortedListToBSTHelper(int length) {
    if (length <= 0) return null;
    TreeNode left = sortedListToBSTHelper(length / 2);
    TreeNode root = new TreeNode(current.val);
    current = current.next;
    TreeNode right = sortedListToBSTHelper(length - length / 2 - 1);
    root.left = left;
    root.right = right;
    return root;
}
#+END_SRC

自己的解法是从根到叶的一种从上而下的解法，而这种解法是从下往上的解法，扫描
一遍原链表即可，要优于自己的解法。

** Romve Duplicates from Sorted List I [Easy]
Given a sorted linked list, delete all duplicates such that each element 
appear only once.

*Example*

Given 1->1->2, return 1->2.
Given 1->1->2->3->3, return 1->2->3.

*思路*

从左往右扫描一遍链表即可

#+CAPTION: Remove Duplicates Sorted List I
#+NAME:   fig:RemoveDuplicatesI
[[../image/DeleteDuplicatesI.png]]

p从左往右扫描链表，每次x从p的下一个Node开始扫描，碰到与p的val不同的Node就
停下来，此时再修改p的next，使得连续相同的元素仅保留一个。

